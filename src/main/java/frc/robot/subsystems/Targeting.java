// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;
import com.ctre.phoenix.sensors.PigeonIMU;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.controller.PIDController;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
/**
 *
 */
public class Targeting extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private NetworkTable limeData;
    // t stands for target
    private NetworkTableEntry tAcquired;
    // x and y values of the target
    private NetworkTableEntry tx;
    private NetworkTableEntry ty;

    private double vP = 0.5;
    private double vI = 0.0;
    private double vD = 4.0;

    private double CONFIRMED_THRESHOLD = 1.0;
    private double CONFIRMED_TIME = .25; // Amount of seconds before it considers a target confirmed
    private double integral;
    private double lastError = 0.0;
    private double STATIC_POWER = 0.05;
    private double currentOutput = 0.0;
    private double INTEGRAL_LIMIT = 1000000000; // TODO Check math and get an actual number

    private Timer confirmTargetTime;

    public Targeting() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        limeData = NetworkTableInstance.getDefault().getTable("limelight");
        tAcquired = limeData.getEntry("tv");
        tx = limeData.getEntry("tx");
        ty = limeData.getEntry("ty");

        limeData.getEntry("camMode").setNumber(0);
  
        SmartDashboard.putNumber("P Gain", vP);
        SmartDashboard.putNumber("I Gain", vI);
        SmartDashboard.putNumber("D Gain", vD);
        
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        double p = SmartDashboard.getNumber("P Gain", 0);
        double i = SmartDashboard.getNumber("I Gain", 0);
        double d = SmartDashboard.getNumber("D Gain", 0);

        if((p != vP)) {vP = p;}

        if((i != vI)) {vI = i; }

        if((d != vD)) {vD = d; }

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // This method just returns whether it sees the target and it's x and y values
    public void controlLight(boolean enabled){
        if(enabled){
            limeData.getEntry("ledMode").setNumber(3);
        }
        else{
            limeData.getEntry("ledMode").setNumber(1);
        }
    }

    public double[] navToTarget(){
        limeData.getEntry("ledMode").setNumber(3);
        double[] velCmds = {0.0,0.0,0.0}; //Left motor velocity, Right motor velocity (retunrns -1 to 1), At the target for a period of time
        if (tAcquired.getDouble(0.0) == 1.0){
            double limeError = tx.getDouble(0.0);
            double headingError = limeError/29.5; // 29.5 is the range of the limelight which goes from -29.5 to 29.5
            double change = headingError - lastError;
            if(Math.abs(integral) < INTEGRAL_LIMIT){
                integral += headingError * .2;
            }
            double percentOutput = (vP * headingError) + (vI * integral) + (vD * change);
            if(percentOutput > .5){
                percentOutput = .5;
            }
            else if(percentOutput < -.5){
                percentOutput = -.5;
            }
    
            velCmds[0] = -percentOutput; //Left Motor
            velCmds[1] = percentOutput; //Right Motor
            SmartDashboard.putNumber("LeftOutput",velCmds[0]);
            SmartDashboard.putNumber("RightOutput",velCmds[1]);
            currentOutput = percentOutput;
            lastError = headingError;

            // Checking if target has been in range for a certain amount of time
            if(Math.abs(limeError) < CONFIRMED_THRESHOLD){
                if(confirmTargetTime.get() != 0.0){
                    confirmTargetTime.start();
                    velCmds[2] = 0.0;
                }
                else if(confirmTargetTime.get() >= CONFIRMED_TIME){
                    velCmds[2] = 1.0;
                }
                else{
                    velCmds[2] = 0.0;
                }
            }
            else{
                confirmTargetTime.reset();
                confirmTargetTime.stop();
                velCmds[2] = 0.0;
            }
           
        }
        
        return velCmds;
    }

    public double calcShooterRPM(){
        double distance = ty.getDouble(0.0);
        if(tAcquired.getDouble(0.0) == 1.0)
            return 1200.0; //TODO Substitute for calculations w/ distance
        else{
            return 0.0;
        }
    }

    public void resetPID(){
        integral = 0.0;
        lastError = 0.0;
    }
     
}
